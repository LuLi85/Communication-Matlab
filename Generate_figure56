%Coordinated Multi-Cell Systems
%This is Uplink Pareto boundary with BSs assignment
close all;
clear all;

%%Simulation parameters
global LBS;
LBS = 6; %Number of avaliable base stations
global mode;
mode = 0;%0: the network-centric BSs assignment; 1: the user-centric BS assignment
NC = 2; %Number of activation BSs.
K = 2; %Number of users (in total)
Nt = 2; %Number of antennas per BS

%rng('shuffle'); %Initiate the random number generators with a random seed
%rng(10); %generate fixed seed

%%If rng('shuffle'); is not supported by your Matlab version, you can use
%%the following commands instead:
randn('state',17);
rand('state',3); %for channel realization 1
randn('state',20);
rand('state',30);%for channel realization 2

PdB = 10; %SNR (in dB)
P = 10.^(PdB/10); %SNR
q = ones(K,1)*P; %Limits of the L power constraints. Note that these have been normalized.

%Generation of normalized Rayleigh fading channel realizations with unit
%variance to closest base station and 1/3 as variance from other base station.
pathlossOverNoise = 2/3* eye(K,LBS) + 1/3*ones(K,LBS);
pathlossOverNoise = rand(K,LBS);
H = sqrt(kron(pathlossOverNoise,ones(1,Nt))).*(randn(K, Nt*LBS) + 1i*randn(K,Nt*LBS))/sqrt(2);
%the above is for downlink model, the uplink is the conj transpose
G = H';

%%Approach 1: Calculate sample points on the Pareto boundary by applying
%%Theorem 3.4 on fine grid of weighting vectors.

disp('Progress: for dynamic BSs assignment'); %Output of the simulation progress
feasibilityMode = 2;
delta = 0.05; %Accuracy of the line searches in the FPO algorithm

nbrOfSamplesFPO = 101; %Number of sample points
ParetoBoundary = zeros(K,nbrOfSamplesFPO); %Pre-allocation of sample matrix

%Initialize D-matrices for global activation and joint transmission
D = repmat(eye(LBS*Nt),[1 1 K]);
%D are variables according to BSs assignment

%Compute normalized beamforming vectors for MRC
wMRC = functionMRC(G,D); 
utopia = zeros(K,1);

%uplink: scale WMRC has no influence for the SINR
for k = 1:K
%     temp = [];
%     for l=1:LBS
%     temp = [temp wMRC(k, (Nt*(l-1)+1):Nt*l)/norm(wMRC(k,(Nt*(l-1)+1):Nt*l)) ];
%     end
%     wMRC(k,:)=temp;
    utopia(k) = log2(1+abs(wMRC(k,:)* G(:,k) )^2*P/ abs(wMRC(k,:)*eye(LBS*Nt)*wMRC(k,:)'));
end

%Generate a grid of equally spaced search directions
interval = linspace(0,1,nbrOfSamplesFPO);
profileDirections = [interval; 1-interval];

for m = 1:nbrOfSamplesFPO
%     if(m==50)
%         disp('test');
%     end
    %Output of the simulation progress - since this part takes a long time
    if (mod(m,10) == 1 && mode ==0)
        disp(['Progress: Running network-centric BS assignment, ' num2str(m) ' out of ' num2str(nbrOfSamplesFPO) ' search directions']);
    end
    
    %Search on a line from the origin in each of the equally spaced search
    %directions. The upper point is either on Pareto boundary (unlikely) or
    %outside of the rate region.
    lowerPoint = zeros(K,1);
    upperPoint = sum(utopia) * profileDirections(:,m);
    
    %Find the intersection between the line and the Pareto boundary by
    %solving an FPO problem.
    finalInterval = functionFairnessProfile(H,D,q,delta,lowerPoint,upperPoint,feasibilityMode);
    
    ParetoBoundary(:,m) = finalInterval(:,1); %Save the best feasible point found by the algorithm

end

%Add the single-user points to the Pareto boundary.
%ParetoBoundary = [[0; utopia(2)] ParetoBoundary [utopia(1); 0]];


%Search for the sample points that maximize the sum rate, geometric mean,
%harmonic mean, and max-min fairness, respectively. Note that the accuracy
%of these points improves when the number of sample points is increased.
[~,sumrateIndex] = max(ParetoBoundary(1,:)+ParetoBoundary(2,:));
[~,geomeanIndex] = max(ParetoBoundary(1,:).*ParetoBoundary(2,:));
[~,harmmeanIndex] = max(harmmean(ParetoBoundary,1));
[~,maxminIndex] = max(min(ParetoBoundary,[],1));

mode = 1
 ParetoBoundary2 = zeros(2,nbrOfSamplesFPO);
for m = 1:nbrOfSamplesFPO
%     if(m==50)
%         disp('test');
%     end
    %Output of the simulation progress - since this part takes a long time
    if (mod(m,10) == 1 & mode ==1)
        disp(['Progress: Running user-centric BS selection, ' num2str(m) ' out of ' num2str(nbrOfSamplesFPO) ' search directions']);
    end
    
    %Search on a line from the origin in each of the equally spaced search
    %directions. The upper point is either on Pareto boundary (unlikely) or
    %outside of the rate region.
    lowerPoint = zeros(K,1);
    upperPoint = sum(utopia) * profileDirections(:,m);
    
    %Find the intersection between the line and the Pareto boundary by
    %solving an FPO problem.
    finalInterval = functionFairnessProfile(H,D,q,delta,lowerPoint,upperPoint,feasibilityMode);
    
    ParetoBoundary2(:,m) = finalInterval(:,1); %Save the best feasible point found by the algorithm

end

%Search for the sample points that maximize the sum rate, geometric mean,
%harmonic mean, and max-min fairness, respectively. Note that the accuracy
%of these points improves when the number of sample points is increased.
[~,sumrateIndex] = max(ParetoBoundary(1,:)+ParetoBoundary(2,:));
[~,geomeanIndex] = max(ParetoBoundary(1,:).*ParetoBoundary(2,:));
[~,harmmeanIndex] = max(harmmean(ParetoBoundary,1));
[~,maxminIndex] = max(min(ParetoBoundary,[],1));

[~,sumrateIndex2] = max(ParetoBoundary2(1,:)+ParetoBoundary2(2,:));
[~,geomeanIndex2] = max(ParetoBoundary2(1,:).*ParetoBoundary2(2,:));
[~,harmmeanIndex2] = max(harmmean(ParetoBoundary2,1));
[~,maxminIndex2] = max(min(ParetoBoundary2,[],1));

%Plot the rate region generated by the two approaches.
figure;hold on; box on;

plot(ParetoBoundary(1,:),ParetoBoundary(2,:),'k--','LineWidth',1); %Plot result of Approach 1
plot(ParetoBoundary2(1,:),ParetoBoundary2(2,:),'k-','LineWidth',1); %Plot result of Approach 2
hold on; box on;
%Plot sample points that maximize sum rate, geometric mean,
%harmonic mean, and max-min fairness, respectively.
plot(ParetoBoundary2(1,sumrateIndex2),ParetoBoundary2(2,sumrateIndex2),'ro');
plot(ParetoBoundary(1,sumrateIndex),ParetoBoundary(2,sumrateIndex),'ro');

plot(ParetoBoundary2(1,geomeanIndex2),ParetoBoundary2(2,geomeanIndex2),'sg');
plot(ParetoBoundary(1,geomeanIndex),ParetoBoundary(2,geomeanIndex),'sg');

plot(ParetoBoundary2(1,harmmeanIndex2),ParetoBoundary2(2,harmmeanIndex2),'mv');
plot(ParetoBoundary(1,harmmeanIndex),ParetoBoundary(2,harmmeanIndex),'mv');

plot(ParetoBoundary2(1,maxminIndex2),ParetoBoundary2(2,maxminIndex2),'k*');
plot(ParetoBoundary(1,maxminIndex),ParetoBoundary(2,maxminIndex),'k*');

legend('Pareto Boundary with network-centric BSA','Pareto Boundary with user-centric BSA')

xlabel('log_2(1+SINR_1) [bits/channel use]')
ylabel('log_2(1+SINR_2) [bits/channel use]')
